
// A basic hockshop with a basic storeroom.

#include <move.h>
#include <mudlib.h>
#include <money.h>

inherit ROOM;
inherit COINVALUE;

 object storeroom;

object init_storeroom();

void create()
{
	seteuid(getuid());
	::create();
	set_short( "µ±ÆÌ" );
        set_long( @LONG_DESCRIPTION
ÄãÏÖÔÚ×ß½øÁËÒ»¼ä²¼ÖÃµÃÏàµ±¿¼¾¿µÄÌüÔº£¬ÃÅ¿ÚÒ»ãİÀ¶É«µÄ²¼Á±ÉÏĞ´Öø
ËÄ¸ö´ó×Ö¡¸¶«·½µÚÒ»µ±¡¹£¬Ç½ÉÏÓĞÒ»ÕÅÖ½(paper)£¬´ó¸ÅÊÇËµÒ»Ğ©µ±ÆÌµÄ
ĞĞÊÂ¹æ¾Ø£¬ÎÚÌ´Ä¾×ö³ÉµÄ¸ô´°ááÃæÕıÓĞÒ»Î»ÀÏ³¯·î¶ÔÖøÄãĞ¦¡£
LONG_DESCRIPTION
                );

      set("c_item_desc",(["paper":@C_LONG
ÕâÊÇÒ»ÕÅÊ®·Ö³Â¾ÉµÄ·º»ÆÆ¤Ö½£¬ÉÏÃæ±»ÈËÓÃÎÚÁÁµÄÅ¨Ä«»ÓÈ÷Öø
Á÷ÀûµÄÁ¥Êé£¬Ê¹Äã¿´µÄĞÄ¿õÉñâù¡£Ğ´Öø £º
          
    Ç×°®µÄÍ¬ÈÊÀÏµ±¿Í»§´óÒ¯ÃÇ£¬Ğ¡µêÒ»Ïò±ü³Ö³ÏĞÅÌ¬¶ÈÎª¿Í»§·şÎñ    
£¬È»Îª±ÜÃâ²»±ØÒªÖ®¾À·×£¬ÌØ´Ë¹«¸æĞ¡ÆÌÖ®Ìõ¹æÒÔÕÑ´óĞÅ£¬ÅÎĞ¡µêÓë
¿Í»§¹²Í¬×ñÑ­£¬Ïà»¥¹æ¾ØÎªÊÇ¡£ÏÂÁĞÌõ¹æ £º
             
    Ò»¡¢ÎïÆ·µ±Öµ¾ùÒÔÊ±¼ÛÕÛµÖ±£¹Ü·Ñáá¼ÆËã¡£
     ş¡¢±¾µê×î¶àÖ»½ÓÊÜÍ¬Ò»Î»¿Í»§ËÄ´Î±£¹ÜÎ¯ÍĞ¡£
    Èı¡¢ËùÍĞÎïÆ·ÔÚ±¾µêÅÌµãÊ±¼äÖ®Ç°Î´È¡ÕßÊÓÍ¬Á÷µ±£¬Ğ¡µêµÃÈÎÒâ´¦ÖÃ¡£
    ËÄ¡¢È¡»ØÍĞÎïÊ±±¾ÆÌµÃ×ÃÁ¿ÊÕÈ¡±£¹Ü·ÑÓëÀûÏ¢¡£
                   
    Ğ¡µêµÄÓªÒµÏîÄ¿ÓĞ£º µ±Îï (pawn)¡¢Êê»Øµ±Îï(take)¡¢²éÑ¯µ±Îï(list)
£¬ÇëÄú¶à¶àÕÕ¹ËĞ¡µêµÄÉúÒâ¡£Ğ»Ğ» !!
       
    ÓĞĞèÒªÍĞÎï·şÎñµÄÇëÃæÇ¢±¾ÆÌ´ó³¯·î¡£                
C_LONG
]));
                                                            
        set( "exits", ([
         "north" : "/d/noden/farwind/bazz1"
         ]) );
                                                                                	                                                            
	set("light",1);

	/* Force the warehouse to load, if it's not loaded  */
	storeroom = init_storeroom();
}

void init()
{
	add_action("list", "list");
	add_action("take", "take");
	add_action("impawn", "pawn");
//	add_action("enter_storeroom", "storeroom");
}

object init_storeroom()
{
	object *room, stroom;
	int i;

	room = children("/std/shop/storeroom");
	for(i=0; i<sizeof(room); i++) {
		if( (string)room[i]->query("linked_shop")==base_name(this_object()) )
			return room[i];
	}
	stroom = new("/d/eastland/goomay/storeroom");
	if( stroom ) return stroom;
	else throw( "Shop: Error in loading storeroom.\n" );
}


void convert_value( object ob )
{
	mixed *value;
	int val;

	value = ob->query( "value" );
	if( !value || !pointerp(value) ) {
		ob->delete("value");
		return;
	}
	if( !intp(value[0]) || value[0]==0 || !stringp(value[1]) ) {
		ob->delete("value");
		return;
	}
	val = value[0] * coinvalue( value[1] ) / coinvalue("silver");
	if( val==0 ) val = 1;
	ob->set( "value", ({ val, "silver" }) );
	return;
}

int list(string arg)
{
	int i, number;
	mixed *value;
	mixed *ob;
	string type;

	write("Äãµ±ÔÚÕâÀïµÄÎïÆ·ÓĞ :\n");

	/* Objects in local storage */
	ob = all_inventory(storeroom);
	if( arg && arg!="" ) 
	   ob = filter_array(ob, "filter_inv", this_object(), arg);
	
	for (i=0; i<sizeof(ob); i++)
	{
	if ((string)ob[i]->query("owner") != (string)this_player()->query("name")) continue;
		value = ob[i]->query("value");
		if (!value) continue;
		type = value[1];
		number = value[0]*3/4;
		if (number==0) continue;

			printf("  %-34s %5d %s\n", ob[i]->query("short")
			+ "(" + ob[i]->query("name") + ")",
			number, to_chinese(type + " coin") );
	}

	return 1;
}

int filter_inv(object ob, string name)
{
	if( name=="weapons" && !undefinedp(ob->query("weapon_class")) ) return 1;
	if( name=="armors" && !undefinedp(ob->query("armor_class")) ) return 1;
	else return (int)ob->id(name);
}

int take(string str)
{
	int number, res, skill,i,j;
	string type, unit,owner;
	object ob;
	mixed *value;
	mixed *ob2,*ob3;

	owner=this_player()->query("name");
	/* Look for the object, first in central storage then in local storage. */
	if (!str)
		return notify_fail( 
			"ÄúÒªÊê»ØÊ²÷á£¿\n");

        if( str && str!="" )
	{
        ob2 = all_inventory(storeroom);
        for (i=0; i<sizeof(ob2); i++)
        {
	if ((string)ob2[i]->query("owner") != owner) continue;
	ob3=ob2[i]->query("id");
	for (j=0; j<sizeof(ob3); j++)
	  {
		if (ob3[j] != str) continue;
		else 
		{
			ob=ob2[i];
			i=sizeof(ob2)-1;
			j=sizeof(ob3)-1;
		}
	  }
	}

	}

	if (!ob)
		return notify_fail(
			"ÄãÃ»ÓĞÔÚµêÀïµ±¹ıÕâÑùµÄ¶«Î÷¡£\n");

	value = ob->query("value");
	if( !value) {
		ob->remove();
		return notify_fail( 
			"ÕâÑù¶«Î÷²»Ó¦¸Ã³öÏÖµêÀï....¡£\n");
	}
	type = value[1];
	number = value[0]*3/4;
	if( number==0) {
		ob->remove();
		return notify_fail( 
			"ÕâÑù¶«Î÷²»Ó¦¸Ã³öÏÖµêÀï....¡£\n");
	}
	skill = this_player()->query_skill("trading");
	number -= number * random(skill) / 300;

	// Check to see if the player has exact change.
	if( this_player()->debit( type, number ) ) {
		// See if the player can carry the object.
		res = ob->move(this_player());
		if (res==MOVE_OK) {
			ob->delete("owner");
			if( skill > 0 ) write( 
				"¾­¹ıÒ»·¬ÌÖ¼Û»¹¼Û£¬");
			if( !(unit = ob->query("unit")) ) unit = "¸ö";
			write(
				"Äã»¨ " + number + " Ã¶" + to_chinese(type + " coin") + "Êê»ØÒ»" + unit + ob->query("short") + "¡£\n");
			tell_room( this_object(), 
				this_player()->query("c_name")+"Êê»ØÒ»"+unit+ob->query("short")+"¡£\n",
				this_player());
			return 1 ;
		} else {
			// Give him his money back.
			this_player()->credit( type , number );
			return notify_fail(
				"ÄãÒÑ¾­¿¸²»¶¯ÆäËû¶«Î÷ÁË¡£\n");
		}
	}

	return notify_fail(
		"ÄãÉíÉÏÃ»ÓĞºÏÊÊµÄÇ®±ÒÄÜÊê»ØÕâÑù¶«Î÷¡£\n");
}
/*
int in_storeroom( object item ) {
    object *items;
    string item_name;
    int i, count, storage;
    
    items = all_inventory(storeroom);
    if( !storeroom->query("storage") ) storage = 1;
    else storage = (int)storeroom->query("storage");
    if( storage < 1 ) storage = 1;
    count = 0;
    if( !sizeof(items) ) return 0;
    item_name = (string)item->query("name");
    for( i=0; i<sizeof(items); i++ )
      if( item_name == (string)items[i]->query("name") )
        count++;
      if( count >= storage ) return 1;
    return 0;
}
*/

int impawn(string str)
{
	int *rate, i, j, l, will_remove, res, skill;
	object ob,*ob2 ;
	string type, unit;
	mixed *value ;
	int number ;

	skill = this_player()->query_skill( "trading" );
        if (this_player()->query("make-up")) return notify_fail("±¾µê²»ºÍ´÷Ãæ¾ßµÄ¿ÍÈË½»Ò×¡£\n");
	if (!str) 
		return notify_fail( 
			"ÄãÒªµ±Ê²÷á¶«Î÷£¿\n");

	ob = present(str, this_player()) ;
	if (!ob)
		return notify_fail( 
			"ÄãÃ»ÓĞÕâÑù¶«Î÷¡£\n");
	if ( this_player()->query("make-up"))
		return notify_fail("ÇëÏÈÈ¥³ı»¯×°ááÔÙÀ´µ±¶«Î÷ !!\n");

	convert_value(ob);
	value = ob->query("value");
	if( !value )
		return notify_fail( 
			"ÄÇ¶«Î÷²»ÖµÇ®\n");

	ob2 = all_inventory(storeroom);
	j=0;
	for (i=0; i<sizeof(ob2); i++)
	{
        if ((string)ob2[i]->query("owner") != (string)this_player()->query("name")) continue;
	j++;
	}
	if (j>=4)
	return notify_fail( 
	"ÄãÒÑ¾­µ±ÁËËÄ¼ş¶«Î÷ÔÚµêÀïÁË¡£\n" );
    number = value[0]*3/4 ;
	if (!this_object()->query("rating"))
	  number = number * SHOP_SALES_FRAC;
	else {
	rate = (int *)this_object()->query("rating");
	  number = number * rate[0] / rate[1];
	}
	number -= number * ( 75 - skill ) / 200;
	if(number>1000) number = 1000;

	if( ob->query("prevent_drop") || ob->query("secure") ||
		ob->query("prevent_insert") )
		return notify_fail(
			"Äã²»ÄÜµ±ÕâÑù¶«Î÷¡£\n");
	type = value[1];

	res = ob->move(storeroom) ;
	if (res != MOVE_OK)
		return notify_fail( 
			"¶Ô²»Æğ£¬ÉÌµê²»ÊÕÕâÖÖ¶«Î÷¡£\n");

	this_player()->credit(type, number) ;
	ob->set("owner",this_player()->query("name"));
	if( !(unit = ob->query("unit")) ) unit = "¸ö";
	write( 
		"Äãµ±µô"+ob->query("short")+"£¬»ñµÃ "+ number +" ¿é"+ to_chinese(type+" coin")+"¡£\n");
	tell_room( this_object(), 
		this_player()->query("c_name")+"µ±µôÒ»"+unit+ob->query("short")+"¡£\n",
		this_player() );

	return 1;
}

int enter_storeroom()
{
	if (!wizardp(this_player())) return 0;
	this_player()->move(storeroom);
	write( "ÄãÍµÍµÁï½øµêÀïµÄ´¢²ØÊÒ.\n");
	say( this_player()->query("c_name") + "Í»È»²»¼ûÁË.\n");
	return 1 ;
}

object storeroom() { return storeroom; }

void clean_up() { return 0; }
